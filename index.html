<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>Dijkstra 算法演示</title>
<style>
body { font-family: 'Segoe UI', Arial; background: #f5f5f5; color:#333; margin: 20px; }
h1 { text-align:center; color:#4CAF50; }
.container { max-width:900px; margin:0 auto; background:#fff; padding:20px; border-radius:10px; box-shadow:0 4px 15px rgba(0,0,0,0.1);}
textarea { width:100%; height:120px; border-radius:5px; border:1px solid #ccc; padding:5px; font-family:monospace;}
input[type=number] { width:60px; padding:5px; margin-left:5px; border-radius:5px; border:1px solid #ccc;}
button { background:#4CAF50; color:#fff; padding:8px 16px; border:none; border-radius:5px; cursor:pointer; font-size:14px; transition:0.2s; }
button:hover { background:#45a049; }
#graph { position: relative; width: 600px; height: 600px; border:1px solid #ccc; margin:20px auto; border-radius:10px; background: #fafafa; }
.node { width:40px; height:40px; border-radius:50%; display:flex; justify-content:center; align-items:center; position:absolute; color:white; font-weight:bold; transition:0.3s; }
.edge { position:absolute; width:2px; background-color:#999; transform-origin: top left; transition:0.3s; }
.edge-label { position:absolute; background:#fff; padding:1px 3px; border:1px solid #999; border-radius:3px; font-size:12px; }
#result { white-space: pre-wrap; margin-top:10px; background:#f0f0f0; padding:10px; border-radius:5px;}
.highlight { background:#FF5722 !important; }
</style>
</head>
<body>
<div class="container">
<h1>Dijkstra 算法可视化</h1>
<p>输入图（每行：from to weight，支持任意数字节点）：</p>
<textarea id="graphInput">0 1 2
0 2 4
1 2 1
1 3 7
2 4 3
3 5 1
4 3 2
4 5 5</textarea>

<p>起点: <input type="number" id="startNode" value="0"> 终点: <input type="number" id="endNode" value="5"></p>
<button onclick="runDijkstra()">计算最短路径</button>

<div id="graph"></div>
<pre id="result"></pre>
</div>

<script>
// 检查是否有负权边
function hasNegativeEdge(edges){
    for(let e of edges){
        if(Number(e[2])<0) return true;
    }
    return false;
}

// 最小堆
class MinHeap {
    constructor() { this.heap=[]; }
    push(item){ this.heap.push(item); this.bubbleUp(); }
    pop(){ const top=this.heap[0]; const end=this.heap.pop(); if(this.heap.length>0){this.heap[0]=end; this.sinkDown();} return top; }
    bubbleUp(){ let idx=this.heap.length-1; const e=this.heap[idx]; while(idx>0){ let p=Math.floor((idx-1)/2); if(e[0]>=this.heap[p][0]) break; this.heap[idx]=this.heap[p]; idx=p; } this.heap[idx]=e; }
    sinkDown(){ let idx=0; const len=this.heap.length; const e=this.heap[0]; while(true){ let l=2*idx+1, r=2*idx+2, swap=null; if(l<len && this.heap[l][0]<e[0]) swap=l; if(r<len && this.heap[r][0]< (swap===null?e[0]:this.heap[l][0])) swap=r; if(swap===null) break; this.heap[idx]=this.heap[swap]; idx=swap; } this.heap[idx]=e; }
    size(){ return this.heap.length; }
}

// Dijkstra 算法（堆优化）
function dijkstra(adj,start){
    const dist={},prev={},visited={};
    Object.keys(adj).forEach(n=>{ dist[n]=Infinity; prev[n]=null; visited[n]=false; });
    dist[start]=0;
    const heap=new MinHeap(); heap.push([0,start]);
    while(heap.size()>0){
        const [d,u]=heap.pop();
        if(visited[u]) continue;
        visited[u]=true;
        (adj[u]||[]).forEach(({to,weight})=>{
            const alt=d+weight;
            if(alt<dist[to]){
                dist[to]=alt; prev[to]=u; heap.push([alt,to]);
            }
        });
    }
    return {dist,prev};
}

// 绘制图形
function drawGraph(nodes, edges, path){
    const graphDiv=document.getElementById('graph');
    graphDiv.innerHTML='';
    const positions={};
    nodes.forEach((n,i)=>{
        const nodeDiv=document.createElement('div');
        nodeDiv.className='node';
        nodeDiv.id='node-'+n;
        nodeDiv.innerText=n;
        const angle=2*Math.PI*i/nodes.length;
        const radius=250;
        const x=300+radius*Math.cos(angle)-20;
        const y=300+radius*Math.sin(angle)-20;
        nodeDiv.style.left=x+'px';
        nodeDiv.style.top=y+'px';
        nodeDiv.style.background=`linear-gradient(135deg,#4CAF50,#81C784)`;
        graphDiv.appendChild(nodeDiv);
        positions[n]={x:x+20,y:y+20};
    });
    edges.forEach(e=>{
        const from=positions[e.from], to=positions[e.to];
        const dx=to.x-from.x, dy=to.y-from.y, len=Math.sqrt(dx*dx+dy*dy);
        const edgeDiv=document.createElement('div');
        edgeDiv.className='edge';
        edgeDiv.style.width=len+'px';
        edgeDiv.style.left=from.x+'px';
        edgeDiv.style.top=from.y+'px';
        edgeDiv.style.transform=`rotate(${Math.atan2(dy,dx)}rad)`;
        graphDiv.appendChild(edgeDiv);
        const label=document.createElement('div');
        label.className='edge-label';
        label.style.left=(from.x+dx/2)+'px';
        label.style.top=(from.y+dy/2)+'px';
        label.innerText=e.weight;
        graphDiv.appendChild(label);
    });
    path.forEach(n=>{ const nd=document.getElementById('node-'+n); if(nd) nd.classList.add('highlight'); });
}

function runDijkstra(){
    const input=document.getElementById('graphInput').value.trim().split('\n');
    const edges=[],nodes=new Set();
    for(let line of input){
        const [f,t,w]=line.trim().split(/\s+/).map(Number);
        edges.push([f,t,w]);
        nodes.add(f); nodes.add(t);
    }

    if(hasNegativeEdge(edges)){
        alert('警告：图中存在负权边，Dijkstra算法不适用！');
        return;
    }

    const adj={};
    edges.forEach(([f,t,w])=>{
        if(!adj[f]) adj[f]=[];
        adj[f].push({to:t,weight:w});
    });

    const start=document.getElementById('startNode').value;
    const end=document.getElementById('endNode').value;
    const nodeArr=Array.from(nodes);

    const {dist,prev}=dijkstra(adj,start);

    const path=[];
    let cur=end;
    while(cur!==null){ path.unshift(cur); cur=prev[cur]; }

    const result=document.getElementById('result');
    if(dist[end]===Infinity) result.textContent=`从 ${start} 到 ${end} 无路径`;
    else result.textContent=`最短路径: ${path.join(' -> ')}，距离: ${dist[end]}`;

    if(nodeArr.length<=100){
        document.getElementById('graph').style.display='block';
        drawGraph(nodeArr,edges,path);
    }else{
        document.getElementById('graph').style.display='none';
    }
}
</script>
</body>
</html>
